\section{Conclusions and Future Work}

In this paper we propose that by fuzzing variations of a target program generated by a mutation testing tool, it may be possible to work around some fundamental limitations of coverage-driven fuzzing.  For the most part, even when not effective, the technique proposed should be low-cost and at worst equivalent to fuzzing the target program itself for a somewhat smaller time.  Our experiments show that fuzzing mutants is trivial to implement (and applies to any fuzzer of which we are aware) and effective for improving branch coverage across a large set of benchmarks, evaluated using Google's FuzzBench platform.  Our methods, by the two primary FuzzBench ranking approaches, scored highest, and improvements over existing high-quality fuzzers were sometimes large.

Future work, in addition to the completion of full FuzzBench experiments to evaluate the technique and answer all research questions, would include exploring the effectiveness of using mutation selection methods and prioritization techniques in addition to those proposed here, and applying directed greybox fuzzing \cite{AFLGo} to specifically target mutated code.  Another possibility is to use Higher Order Mutants \cite{HOM} to fuzz multiple mutants at once; however, this increases the chance that a critical mutant will be combined with a mutant that essentially destroys the program semantics, making it impossible to exploit.

Finally, our difficulties with FuzzBench build restrictions turned out to possibly be beneficial, in that they inclined us to consider the possibility of \emph{not using source-level mutants at all}.  The existence of binary-based mutation tools such as SN4KE \cite{SN4KE} suggests that mutation could be applied to a single target binary, instead of to source code.  This has a notable advantage beyond making FuzzBench experiments much easier, in that, like QEMU-based fuzzers such as the AFL QEMU mode and the original Eclipser, it works for fuzzing binaries without source code.    The primary disadvantage of binary or bytecode level mutation, that humans cannot easily understand such mutants or their implications, is irrelevant: the fuzzer does not need to understand source-level impacts of semantic changes.  The changes useful for fuzzing are obviously equally available at the binary/assembly level as at the source level, and in fact binary-level mutants may introduce useful operators not easily implemented at the source level.  The largest obstacle to this approach is the lack of maturity in binary-level mutation tools compared to source-level mutation tools, for C and C++ code, and, most importantly, the challenge of avoiding mutating fuzzer instrumentation itself.  The latter problem does not apply to QEMU-based fuzzing, however. Moreover, we speculate that fuzzer instrumentation is typically much less than half of an instrumented binary's code size, often as little as 25\%, and so most mutants at binary level would modify relevant target program code.  Using knowledge of fuzzer instrumentation implementation it might also be easy to avoid mutating instrumentation.  Finally, it is possible that some mutants to instrumentation could be beneficial, and that most would be harmless, so in some sense the difference between target code and instrumentation code mutants is less important than might at first seem to be the case.

\section*{Acknowledgements}
\begin{sloppypar}
  A portion of this work was  supported by the National Science Foundation under CCF-2129446.  The
authors would also like to thank our anonymous reviewers, as well as Yoshiki Takashima and Maverick Woo; and we would especially like to thank the FuzzBench team, and Jonathan Metz in particular.
\end{sloppypar}
