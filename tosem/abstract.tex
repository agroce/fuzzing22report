Most fuzzing efforts, very understandably, focus on fuzzing the program
in which bugs are to be found.  However, in this paper we propose that
fuzzing programs ``near'' the System Under Test (SUT) can in fact
improve the effectiveness of fuzzing, even if it means less time is
spent fuzzing the actual target system.  In particular, we claim that
fault detection and code coverage can be improved by splitting fuzzing
resources between the SUT and \emph{mutants} of the SUT.  Spending
half of a fuzzing budget fuzzing mutants, and then using the seeds
generated to fuzz the SUT can allow a fuzzer to explore more behaviors
than spending the entire fuzzing budget on the SUT.  The approach
works because fuzzing most mutants is ``almost'' fuzzing the SUT, but
may change behavior in ways that allow a fuzzer to reach deeper
program behaviors.  Our results using Google's FuzzBench platform show that fuzzing mutants
is trivial to implement and fuzzer-agnostic, but provides clear, statistically significant
benefits in terms of branch coverage for a number of
real-world benchmarks, using AFLplusplus and Honggfuzz as baseline
fuzzers.  One of the variants of our method ranks first by both of the two standard measures of fuzzer effectiveness
provided by FuzzBench.  